from django.forms import inlineformset_factory, modelform_factory
from django.utils.translation import gettext as _
from crispy_forms.layout import Layout
from django.apps import apps


class FielderMixin:
    """
    A mixin that provides helper methods for building model forms, inline formsets,
    and filtering form fields based on user permissions.
    
    Assumptions:
        - The implementing view provides get_model(), get_form_fields(), and formsets().
        - The requesting user has a method `get_user_field_permission()` that returns a
          dictionary mapping field names to permission flags.
    """

    def inline_model_form(self, target_model):
        """
        Build and return a custom modelform class for the given inline (child) model.
        This is achieved by:
          1. Creating a temporary form instance using modelform_factory with the inline form fields.
          2. Applying the filter_form() on the temporary instance to set widgets/attributes.
          3. Re-creating the modelform using the widgets from the filtered instance.

        Args:
            target_model: The inline (child) model for which to build the form.

        Returns:
            A customized modelform class for the inline model.
        """
        # Build a temporary form instance to get the correct widget instances.
        initial_fields = self.get_inline_form_fields(target_model)
        TempForm = modelform_factory(target_model, fields=initial_fields)
        temp_form_instance = self.filter_form(TempForm())
        
        # Build the final form class, reusing the filtered widget configurations.
        widgets = {field: temp_form_instance.fields[field].widget for field in temp_form_instance.fields}
        return modelform_factory(
            target_model, 
            fields=initial_fields,
            widgets=widgets
        )

    def formsets(self, can_delete=True, extra=1):
        """
        Constructs and returns a list of inline formset classes for the current model.

        It retrieves a tuple of inline definitions from the parent model's 'inlines' attribute,
        transforms each inline (a dotted string) into a model class, and builds an inline formset
        using the respective custom inline form generated by inline_model_form().

        Args:
            can_delete (bool): Whether objects in the inline formset can be marked for deletion.
            extra (int): The number of extra forms to display.

        Returns:
            A list of inline formset classes.
        """
        parent_model = self.get_model()
        inline_definitions = getattr(parent_model, 'inlines', tuple())
        inline_models = [apps.get_model(*inline.split('.')) for inline in inline_definitions]

        formset_list = []
        for target_model in inline_models:
            formset_cls = inlineformset_factory(
                parent_model, 
                target_model,
                form=self.inline_model_form(target_model),
                fields=self.get_inline_form_fields(target_model), 
                can_delete=can_delete, 
                extra=extra
            )
            formset_list.append(formset_cls)
        return formset_list

    def filter_form(self, form):
        """
        Apply user-based field permission filtering to the given form.
        For each field that the user does not have permission to modify,
        mark the widget as readonly and apply a dark background class.
        
        Args:
            form: Either a form instance or class; if a class, it is instantiated.

        Returns:
            The filtered form instance.
        """
        # Instantiate the form if a form class is passed.
        form_instance = form() if isinstance(form, type) else form
        permission_dict = self.request.user.get_user_field_permission(
            app=form_instance.Meta.model._meta.app_label,
            model=form_instance.Meta.model._meta.model_name
        )
        for field, has_permission in permission_dict.items():
            if not has_permission:
                # Mark the field as read-only and change style
                form_instance.fields[field].widget.attrs['readonly'] = True
                form_instance.fields[field].widget.attrs['class'] = 'bg-dark'
        return form_instance

    def get_form_fields(self, model=None):
        """
        Retrieve a list of field names to show on the form.
        It checks if the model defines a 'layout' attribute (expected to be a crispy Layout)
        and returns all field names from that layout; otherwise returns an empty list.

        Args:
            model: Optional model class; if not provided, self.get_model() is used.

        Returns:
            A list of field names.
        """
        target_model = model or self.get_model()
        layout = getattr(target_model, 'layout', Layout())
        return [field.name for field in layout.get_field_names()]

    def get_inline_form_fields(self, model=None):
        """
        Retrieve a list of field names for inline forms.
        It returns the names of fields in the model that have the attribute `inline` set to True.

        Args:
            model: Optional model class; if not provided, self.get_model() is used.

        Returns:
            A list of inline form field names.
        """
        target_model = model or self.get_model()
        return [field.name for field in target_model._meta.fields if getattr(field, 'inline', False)]
